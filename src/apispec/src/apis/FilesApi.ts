/* tslint:disable */
/* eslint-disable */
/**
 * Sandbox0 API
 * Public HTTP APIs exposed by internal-gateway.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiV1SandboxesIdFilesGet200Response,
  MoveFileRequest,
  SuccessCreatedResponse,
  SuccessDeletedResponse,
  SuccessFileListResponse,
  SuccessFileStatResponse,
  SuccessMovedResponse,
  SuccessWrittenResponse,
} from '../models/index';
import {
    ApiV1SandboxesIdFilesGet200ResponseFromJSON,
    ApiV1SandboxesIdFilesGet200ResponseToJSON,
    MoveFileRequestFromJSON,
    MoveFileRequestToJSON,
    SuccessCreatedResponseFromJSON,
    SuccessCreatedResponseToJSON,
    SuccessDeletedResponseFromJSON,
    SuccessDeletedResponseToJSON,
    SuccessFileListResponseFromJSON,
    SuccessFileListResponseToJSON,
    SuccessFileStatResponseFromJSON,
    SuccessFileStatResponseToJSON,
    SuccessMovedResponseFromJSON,
    SuccessMovedResponseToJSON,
    SuccessWrittenResponseFromJSON,
    SuccessWrittenResponseToJSON,
} from '../models/index';

export interface ApiV1SandboxesIdFilesDeleteRequest {
    id: string;
    path: string;
}

export interface ApiV1SandboxesIdFilesGetRequest {
    id: string;
    path: string;
}

export interface ApiV1SandboxesIdFilesListGetRequest {
    id: string;
    path: string;
}

export interface ApiV1SandboxesIdFilesMovePostRequest {
    id: string;
    moveFileRequest: MoveFileRequest;
}

export interface ApiV1SandboxesIdFilesPostRequest {
    id: string;
    path: string;
    mkdir?: boolean;
    recursive?: boolean;
    body?: Blob;
}

export interface ApiV1SandboxesIdFilesStatGetRequest {
    id: string;
    path: string;
}

export interface ApiV1SandboxesIdFilesWatchGetRequest {
    id: string;
}

/**
 * 
 */
export class FilesApi extends runtime.BaseAPI {

    /**
     * Delete file or directory
     */
    async apiV1SandboxesIdFilesDeleteRaw(requestParameters: ApiV1SandboxesIdFilesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessDeletedResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SandboxesIdFilesDelete().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling apiV1SandboxesIdFilesDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sandboxes/{id}/files`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessDeletedResponseFromJSON(jsonValue));
    }

    /**
     * Delete file or directory
     */
    async apiV1SandboxesIdFilesDelete(requestParameters: ApiV1SandboxesIdFilesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessDeletedResponse> {
        const response = await this.apiV1SandboxesIdFilesDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use query params: - path=/tmp/a.txt: target file path When `Accept` or `Content-Type` is `application/json`, returns a base64 JSON payload. 
     * Read file content
     */
    async apiV1SandboxesIdFilesGetRaw(requestParameters: ApiV1SandboxesIdFilesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SandboxesIdFilesGet().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling apiV1SandboxesIdFilesGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sandboxes/{id}/files`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Use query params: - path=/tmp/a.txt: target file path When `Accept` or `Content-Type` is `application/json`, returns a base64 JSON payload. 
     * Read file content
     */
    async apiV1SandboxesIdFilesGet(requestParameters: ApiV1SandboxesIdFilesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.apiV1SandboxesIdFilesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use query params: - path=/tmp: target directory path 
     * List directory entries
     */
    async apiV1SandboxesIdFilesListGetRaw(requestParameters: ApiV1SandboxesIdFilesListGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessFileListResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SandboxesIdFilesListGet().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling apiV1SandboxesIdFilesListGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sandboxes/{id}/files/list`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessFileListResponseFromJSON(jsonValue));
    }

    /**
     * Use query params: - path=/tmp: target directory path 
     * List directory entries
     */
    async apiV1SandboxesIdFilesListGet(requestParameters: ApiV1SandboxesIdFilesListGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessFileListResponse> {
        const response = await this.apiV1SandboxesIdFilesListGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move a file or directory
     */
    async apiV1SandboxesIdFilesMovePostRaw(requestParameters: ApiV1SandboxesIdFilesMovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessMovedResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SandboxesIdFilesMovePost().'
            );
        }

        if (requestParameters['moveFileRequest'] == null) {
            throw new runtime.RequiredError(
                'moveFileRequest',
                'Required parameter "moveFileRequest" was null or undefined when calling apiV1SandboxesIdFilesMovePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sandboxes/{id}/files/move`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MoveFileRequestToJSON(requestParameters['moveFileRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessMovedResponseFromJSON(jsonValue));
    }

    /**
     * Move a file or directory
     */
    async apiV1SandboxesIdFilesMovePost(requestParameters: ApiV1SandboxesIdFilesMovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessMovedResponse> {
        const response = await this.apiV1SandboxesIdFilesMovePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use `path` query param and `mkdir=true` to create directories, otherwise writes file content.
     * Write file or create directory
     */
    async apiV1SandboxesIdFilesPostRaw(requestParameters: ApiV1SandboxesIdFilesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessWrittenResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SandboxesIdFilesPost().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling apiV1SandboxesIdFilesPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['mkdir'] != null) {
            queryParameters['mkdir'] = requestParameters['mkdir'];
        }

        if (requestParameters['recursive'] != null) {
            queryParameters['recursive'] = requestParameters['recursive'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sandboxes/{id}/files`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessWrittenResponseFromJSON(jsonValue));
    }

    /**
     * Use `path` query param and `mkdir=true` to create directories, otherwise writes file content.
     * Write file or create directory
     */
    async apiV1SandboxesIdFilesPost(requestParameters: ApiV1SandboxesIdFilesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessWrittenResponse> {
        const response = await this.apiV1SandboxesIdFilesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use query params: - path=/tmp/a.txt: target file path 
     * Stat a file
     */
    async apiV1SandboxesIdFilesStatGetRaw(requestParameters: ApiV1SandboxesIdFilesStatGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessFileStatResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SandboxesIdFilesStatGet().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling apiV1SandboxesIdFilesStatGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sandboxes/{id}/files/stat`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessFileStatResponseFromJSON(jsonValue));
    }

    /**
     * Use query params: - path=/tmp/a.txt: target file path 
     * Stat a file
     */
    async apiV1SandboxesIdFilesStatGet(requestParameters: ApiV1SandboxesIdFilesStatGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessFileStatResponse> {
        const response = await this.apiV1SandboxesIdFilesStatGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upgrades to WebSocket for file watch events. Client messages: - { \"action\": \"subscribe\", \"path\": \"/tmp\", \"recursive\": false } - { \"action\": \"unsubscribe\", \"watch_id\": \"watch-id\" } Server messages: - { \"type\": \"subscribed\", \"watch_id\": \"watch-id\", \"path\": \"/tmp\" } - { \"type\": \"event\", \"watch_id\": \"watch-id\", \"event\": \"write\", \"path\": \"/tmp/a.txt\" } - { \"type\": \"unsubscribed\", \"watch_id\": \"watch-id\" } - { \"type\": \"error\", \"error\": \"message\" } 
     * File watch WebSocket
     */
    async apiV1SandboxesIdFilesWatchGetRaw(requestParameters: ApiV1SandboxesIdFilesWatchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SandboxesIdFilesWatchGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sandboxes/{id}/files/watch`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Upgrades to WebSocket for file watch events. Client messages: - { \"action\": \"subscribe\", \"path\": \"/tmp\", \"recursive\": false } - { \"action\": \"unsubscribe\", \"watch_id\": \"watch-id\" } Server messages: - { \"type\": \"subscribed\", \"watch_id\": \"watch-id\", \"path\": \"/tmp\" } - { \"type\": \"event\", \"watch_id\": \"watch-id\", \"event\": \"write\", \"path\": \"/tmp/a.txt\" } - { \"type\": \"unsubscribed\", \"watch_id\": \"watch-id\" } - { \"type\": \"error\", \"error\": \"message\" } 
     * File watch WebSocket
     */
    async apiV1SandboxesIdFilesWatchGet(requestParameters: ApiV1SandboxesIdFilesWatchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1SandboxesIdFilesWatchGetRaw(requestParameters, initOverrides);
    }

}
